<!DOCTYPE html>
<html lang="tr"> <head>
    <meta charset="UTF-8"> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Yazısı Rakam Tanıma</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
         /* Custom styles for the canvas */
        #drawingCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            background-color: #000; /* Black background for digit drawing */
        }
        /* Style for the visualization container */
        #cnnVisualization {
            min-height: 352px; /* Yüksekliği biraz azaltıldı, yüzdeler aşağıya taşındı */
            background-color: #1a202c; /* Dark background for visualization */
            color: #e2e8f0; /* Light text color */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Hide overflow if visualization is larger */
            position: relative; /* Needed for absolute positioning of visualization elements */
            font-size: 0.9rem; /* Smaller font for placeholder text */
            text-align: center;
            margin-top: 1rem; /* Üstten biraz boşluk */
        }

        /* Style for the prediction probabilities area */
        #predictionProbabilities {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #2d3748;
            border-radius: 0.375rem;
            /* height ve overflow-y kaldırıldı, içerik yüksekliğine göre otomatik ayarlanacak */
            /* Pre-allocate fixed height to prevent layout shifting */
            /* height: 200px; */ /* Yüksekliği sabitlendi */
            /* overflow-y: auto; */ /* İçerik taştığında kaydırma çubuğu çıksın */
        }
        #probabilityList {
            /* Ensure the list itself has minimum height */
            min-height: 150px; /* Minimum yükseklik sağlandı */
            list-style: none; /* Madde işaretlerini kaldır */
            padding: 0;
            display: grid; /* Grid kullanarak yan yana sıralama */
            grid-template-columns: repeat(auto-fit, minmax(85px, 1fr)); /* Otomatik sütun genişliği */
            gap: 0.5rem; /* Elemanlar arası boşluk */
        }


        /* Ensure drawing area stays fixed */
        .flex-1.flex.flex-col.items-center {
            position: relative;
        }

        #drawingCanvas {
            position: sticky;
            top: 0; /* Üstte sabitlendi */
            z-index: 10;
        }

        #predictionProbabilities h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #e2e8f0;
        }

        #predictionProbabilities li {
            background-color: #4a5568; /* Daha koyu gri arka plan */
            padding: 0.5rem;
            border-radius: 0.25rem;
            text-align: center;
            font-size: 0.8rem;
        }

        #predictionProbabilities li strong {
            font-size: 1rem;
            color: #66f9ee; /* Açık turkuaz renk */
        }

        /* Style for the close prediction warning */
        #closePredictionWarning {
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: #f6e05e; /* Sarı arka plan */
            color: #2d3748; /* Koyu gri metin */
            border-radius: 0.375rem;
            font-weight: 600;
            text-align: center;
            display: none; /* Başlangıçta gizli */
        }

        /* Add a placeholder during loading */
        .probabilityPlaceholder {
            grid-column: 1 / -1; /* Tüm sütunları kapla */
            text-align: center;
            align-self: center; /* Dikeyde ortala */
        }


        /* Basic styling for nodes/connections if you were to draw them manually */
        /* This is just an example, a library would handle this better */
        .node {
            width: 10px;
            height: 10px;
            background-color: #4299e1; /* Blue node */
            border-radius: 50%;
            position: absolute;
        }
        .connection {
            position: absolute;
            height: 2px;
            background-color: #a0aec0; /* Gray connection */
            transform-origin: 0 50%; /* Rotate from the start of the line */
        }
        .connection.active {
            background-color: #66f9ee; /* Cyan light-up effect */
            box-shadow: 0 0 8px #66f9ee;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        /* Style for the status indicator */
        #statusMessage {
            position: fixed; /* Fixed position relative to the viewport */
            bottom: 10px; /* 10px from the bottom */
            left: 10px; /* 10px from the left */
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1000; /* Ensure it's above other content */
            background-color: #4a5568; /* Gray background */
            color: #fff; /* White text */
        }


        /* Basic styling for nodes/connections if you were to draw them manually */
        /* This is just an example, a library would handle this better */
        .node {
            width: 10px;
            height: 10px;
            background-color: #4299e1; /* Blue node */
            border-radius: 50%;
            position: absolute;
        }
        .connection {
            position: absolute;
            height: 2px;
            background-color: #a0aec0; /* Gray connection */
            transform-origin: 0 50%; /* Rotate from the start of the line */
        }
        .connection.active {
            background-color: #66f9ee; /* Cyan light-up effect */
            box-shadow: 0 0 8px #66f9ee;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        /* Style for the status indicator */
        #statusMessage {
            position: fixed; /* Fixed position relative to the viewport */
            bottom: 10px; /* 10px from the bottom */
            left: 10px; /* 10px from the left */
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1000; /* Ensure it's above other content */
            background-color: #4a5568; /* Gray background */
            color: #fff; /* White text */
        }

    </style>
    </head>
<body class="bg-gray-900 min-h-screen flex items-center justify-center p-4 text-gray-100">
    <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-6xl">
        <div class="flex flex-col md:flex-row gap-8">
            <div class="flex-1 flex flex-col items-center">
                <h2 class="text-xl font-semibold mb-4 text-gray-200">Rakam Çizin</h2>
                <canvas id="drawingCanvas" width="280" height="280" class="rounded-md"></canvas>
                <button id="clearButton" class="mt-4 px-6 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 transition duration-200">Temizle</button>

                <div id="predictionProbabilities" class="w-full">
                    <h3>Tahmin Olasılıkları:</h3> <ul id="probabilityList">
                        <p class="text-gray-400 italic">Çizim yapıldıkça olasılıklar burada görünecektir.</p>
                    </ul>
                    <div id="closePredictionWarning" class="hidden">
                        Tahminler birbirine yakın!
                    </div>
                </div>
            </div>

            <div class="flex-1 flex flex-col gap-6">
                <div>
                    <label for="epochSlider" class="block text-lg font-semibold mb-2 text-gray-200">Eğitim Sayısı (Model): <span id="epochValue">N/A</span></label> <input type="range" id="epochSlider" min="1" max="100000" value="1" class="w-full h-2 bg-blue-600 rounded-lg appearance-none cursor-pointer opacity-50 cursor-not-allowed" disabled>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-2 text-gray-200">Tahmin Edilen Rakam:</h2> <div id="predictionResult" class="text-4xl font-bold text-center text-green-500 p-4 border-2 border-dashed border-green-600 rounded-md bg-green-900">?</div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-2 text-gray-200">CNN Katmanları Görselleştirme:</h2> <div id="cnnVisualization" class="rounded-md">
                         <p class="text-gray-400 italic">CNN katmanlarının dinamik görselleştirmesi burada gösterilecektir (model çıktılarına göre).</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="statusMessage" class="bg-gray-600 text-white">Bağlanıyor...</div> <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const clearButton = document.getElementById('clearButton');
        const epochSlider = document.getElementById('epochSlider');
        const epochValueSpan = document.getElementById('epochValue');
        const predictionResultDiv = document.getElementById('predictionResult');
        const cnnVisualizationDiv = document.getElementById('cnnVisualization');
        const statusMessageDiv = document.getElementById('statusMessage'); // Get the status div
        const probabilityList = document.getElementById('probabilityList'); // Olasılık listesi elementi
        const closePredictionWarning = document.getElementById('closePredictionWarning'); // Yakın tahmin uyarısı elementi


        let drawing = false;
        let websocket; // WebSocket bağlantısı için
        let lastSendTime = 0; // Son veri gönderme zamanı
        const SEND_INTERVAL = 50; // Veri gönderme aralığı (milisaniye), azaltıldı

        // WebSocket bağlantısını kurma
        function connectWebSocket() {
            // FastAPI'nin WebSocket endpoint'ine bağlanın (aynı port ve adres)
            // window.location.host, HTML dosyasının sunulduğu adresi ve portu otomatik alır.
            websocket = new WebSocket(`ws://${window.location.host}/ws`); // /ws endpoint'ine bağlan

            websocket.onopen = () => {
                console.log('WebSocket bağlantısı kuruldu.'); // Türkçe karakter düzeltildi
                statusMessageDiv.textContent = 'Bağlantı Kuruldu'; // Türkçe karakter düzeltildi
                statusMessageDiv.className = 'bg-green-600 text-white'; // Yeşil arka plan
            };

            websocket.onmessage = (event) => {
                console.log('Sunucudan mesaj alındı:', event.data); // Debug log - Türkçe karakter düzeltildi
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'prediction_result') {
                        // Tahmin edilen rakamı ekranda göster
                        if (data.prediction !== undefined) {
                            predictionResultDiv.textContent = data.prediction;
                        }

                        if (data.cnn_viz_data !== undefined) {
                            console.log("Görselleştirme verisi alındı:", data.cnn_viz_data); // Debug log - Türkçe karakter düzeltildi
                            updateVisualization(data.cnn_viz_data); // Görselleştirme fonksiyonunu çağır
                        }
                    } else if (data.type === 'model_status') { // Backend'den gelen model durumu
                         console.log('Model durumu:', data.message); // Türkçe karakter düzeltildi
                         // Model durumu güncellemelerini burada işleyin (örn: kullanıcıya modelin hazır olduğunu bildirme)
                         if (data.status === 'ready') {
                             statusMessageDiv.textContent = 'Model Hazır'; // Türkçe karakter düzeltildi
                             statusMessageDiv.className = 'bg-green-600 text-white';
                             predictionResultDiv.textContent = '?'; // Model hazır olduğunda ? göster
                         } else if (data.status === 'error') {
                             statusMessageDiv.textContent = 'Model Hatası!'; // Türkçe karakter düzeltildi
                             statusMessageDiv.className = 'bg-red-600 text-white';
                             predictionResultDiv.textContent = '!'; // Hata durumunda ! göster
                             cnnVisualizationDiv.innerHTML = `<p class="text-red-400 italic">Model başlatılırken hata: ${data.message}</p>`; // Türkçe karakter düzeltildi
                         }
                    } else if (data.type === 'processed') {
                        // Sadece işlemin tamamlandığını onayla, tahmin gösterme
                        console.log('İşlem tamamlandı'); // Türkçe karakter düzeltildi
                    } else if (data.type === 'error') { // Sunucudan gelen hata mesajları
                         console.error('Sunucudan hata alındı:', data.message); // Türkçe karakter düzeltildi
                         predictionResultDiv.textContent = '!'; // Hata durumunda ! göster
                         cnnVisualizationDiv.innerHTML = `<p class="text-red-400 italic">Sunucu Hatası: ${data.message}</p>`; // Türkçe karakter düzeltildi
                    }


                } catch (error) {
                    console.error('Mesaj işlenirken hata oluştu:', error); // Türkçe karakter düzeltildi
                    predictionResultDiv.textContent = '!'; // Hata durumunda ! göster
                    cnnVisualizationDiv.innerHTML = '<p class="text-gray-400 italic">Görselleştirme verisi işlenemedi.</p>'; // Türkçe karakter düzeltildi
                }
            };

            websocket.onerror = (error) => {
                console.error('WebSocket hatası:', error); // Türkçe karakter düzeltildi
                statusMessageDiv.textContent = 'Bağlantı Hatası!'; // Türkçe karakter düzeltildi
                statusMessageDiv.className = 'bg-yellow-600 text-white'; // Sarı arka plan
                predictionResultDiv.textContent = 'Hata!'; // Türkçe karakter düzeltildi
                cnnVisualizationDiv.innerHTML = '<p class="text-gray-400 italic">WebSocket hatası oluştu.</p>'; // Türkçe karakter düzeltildi
            };

            websocket.onclose = (event) => {
                console.log('WebSocket bağlantısı kapatıldı:', event.code, event.reason); // Türkçe karakter düzeltildi
                statusMessageDiv.textContent = 'Bağlantı Kapalı'; // Türkçe karakter düzeltildi
                statusMessageDiv.className = 'bg-red-600 text-white'; // Kırmızı arka plan
                predictionResultDiv.textContent = 'Bağlantı Kapalı'; // Türkçe karakter düzeltildi
                cnnVisualizationDiv.innerHTML = '<p class="text-gray-400 italic">WebSocket bağlantısı kapalı.</p>'; // Türkçe karakter düzeltildi
                // Bağlantı kesilirse yeniden bağlanmayı dene (isteğe bağlı)
                // setTimeout(connectWebSocket, 5000); // 5 saniye sonra tekrar dene
            };
        }

        // WebSocket bağlantısını başlat
        connectWebSocket();


        // Drawing functions
        function startDrawing(e) {
            drawing = true;
             console.log("Çizim başladı."); // Debug log - Türkçe karakter düzeltildi
             // Fare pozisyonunu al ve ilk noktayı belirle
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            ctx.beginPath(); // Yeni bir çizgiye başla
            ctx.moveTo(x, y); // Başlangıç noktasını belirle
            console.log(`Çizim başlangıç noktası: (${x}, ${y})`); // Debug log

            draw(e); // Draw a dot when clicking
        }

        function stopDrawing() {
            drawing = false;
            ctx.beginPath(); // Start a new path for the next stroke
             console.log("Çizim durdu."); // Debug log - Türkçe karakter düzeltildi
            // Çizim bittiğinde son bir veri gönder
            sendCanvasData();
        }

        function draw(e) {
            if (!drawing) {
                // console.log("draw fonksiyonu çalışıyor ama drawing=false"); // Debug log
                return;
            }

             // console.log("draw fonksiyonu çalışıyor ve drawing=true"); // Debug log

            try {
                // Get mouse position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                ctx.lineWidth = 20; // Line thickness
                ctx.lineCap = 'round';
                ctx.strokeStyle = '#fff'; // White color for drawing

                ctx.lineTo(x, y); // Mevcut noktadan yeni noktaya çizgi çiz
                ctx.stroke(); // Çizgiyi ekrana yansıt
                // ctx.beginPath(); // Bu satır burada olmamalı, her mouse hareketinde yeni bir path başlatır
                // ctx.moveTo(x, y); // Bu satır da burada olmamalı, çizginin kesik görünmesine neden olur

                // Çizim sırasında veriyi gönder, ancak gönderme hızını sınırla (throttle)
                const now = Date.now();
                if (now - lastSendTime > SEND_INTERVAL) {
                    sendCanvasData();
                    lastSendTime = now;
                }
            } catch (error) {
                console.error("Çizim sırasında hata:", error); // Çizim hatası yakalama - Türkçe karakter düzeltildi
                // Hata durumunda çizimi durdur
                stopDrawing();
            }
        }

        // Canvas verisini WebSocket üzerinden gönder
        function sendCanvasData() {
            if (websocket && websocket.readyState === WebSocket.OPEN) { // Bağlantının açık olduğunu kontrol et
                try {
                    const imageData = canvas.toDataURL('image/png'); // Base64 formatında resim verisi al

                    // JSON obje olarak gönder
                    const dataToSend = {
                        type: 'digit_image',
                        image: imageData
                    };

                    websocket.send(JSON.stringify(dataToSend));
                    // console.log('Canvas verisi gönderildi.'); // Sık loglamayı önlemek için yorum satırı yapıldı - Türkçe karakter düzeltildi
                } catch (error) {
                     console.error("Canvas verisi gönderilirken hata:", error); // Gönderme hatası yakalama - Türkçe karakter düzeltildi
                }
            } else {
                console.warn('WebSocket bağlantısı açık değil. Veri gönderilemedi.'); // Türkçe karakter düzeltildi
                statusMessageDiv.textContent = 'Bağlantı Kapalı'; // Türkçe karakter düzeltildi
                statusMessageDiv.className = 'bg-red-600 text-white';
            }
        }

        // Epoch değeri gönderme (model Python'da eğitildiği için bu kısım şu an pasif)
        function sendEpochValue() {
             if (websocket && websocket.readyState === WebSocket.OPEN) {
                try {
                    const dataToSend = {
                        type: 'epoch_update',
                        epochs: parseInt(epochSlider.value, 10)
                    };
                    websocket.send(JSON.stringify(dataToSend));
                    console.log('Epoch değeri gönderildi:', parseInt(epochSlider.value, 10)); // Türkçe karakter düzeltildi
                } catch (error) {
                     console.error("Epoch değeri gönderilirken hata:", error); // Gönderme hatası yakalama - Türkçe karakter düzeltildi
                }
            } else {
                console.warn('WebSocket bağlantısı açık değil. Epoch değeri gönderilemedi.'); // Türkçe karakter düzeltildi
            }
        }

        // Görselleştirme verisini işleme ve gösterme fonksiyonu
function updateVisualization(vizData) {
    // Olasılık listesini temizle
    const probabilityList = document.getElementById('probabilityList');
    probabilityList.innerHTML = '';

    const closePredictionWarning = document.getElementById('closePredictionWarning');
    closePredictionWarning.classList.add('hidden'); // Always hide warning

    // Check if vizData and prediction_scores exist and is an array
    if (vizData && Array.isArray(vizData.prediction_scores)) {
        // Extract scores correctly - prediction_scores is an array of arrays
        // where the first element is the array of probabilities
        let scores;
        if (vizData.prediction_scores[0] && Array.isArray(vizData.prediction_scores[0])) {
            // It's a nested array [[0.1, 0.2, ...]]
            scores = vizData.prediction_scores[0];
        } else {
            // It's a flat array [0.1, 0.2, ...]
            scores = vizData.prediction_scores;
        }

        // Create probability items for display
        for (let i = 0; i < scores.length; i++) {
            // Ensure score is a number before using toFixed
            const score = typeof scores[i] === 'number' ? scores[i] : 0;

            // Create list item with percentage
            const listItem = document.createElement('li');

            // Format percentage with proper precision
            const percentage = (score * 100).toFixed(2);
            listItem.innerHTML = `Rakam ${i}: <strong>${percentage}%</strong>`;

            probabilityList.appendChild(listItem);
        }
    } else {
        // Handle missing or invalid data
        console.log("Missing or invalid prediction_scores in data:", vizData);
        probabilityList.innerHTML = '<p class="text-gray-400 italic">Çizim yapıldıkça olasılıklar burada görünecektir.</p>';
    }
}

        // Event Listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseout', stopDrawing); // Fare canvas dışına çıktığında çizimi durdur

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000'; // Arka planı siyaha sıfırla
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            predictionResultDiv.textContent = '?'; // Tahmin ekranını sıfırla
            // Görselleştirme alanını sıfırla
            cnnVisualizationDiv.innerHTML = '<p class="text-gray-400 italic">CNN katmanlarının dinamik görselleştirmesi burada gösterilecektir (model çıktılarına göre).</p>'; // Türkçe karakter düzeltildi
             cnnVisualizationDiv.style.backgroundColor = '#1a202c'; // Arka planı sıfırla
             console.log("Canvas temizlendi."); // Debug log - Türkçe karakter düzeltildi

             // Temizle butonuna basıldığında olasılıkları ve uyarıyı da temizle
             probabilityList.innerHTML = '<p class="text-gray-400 italic">Çizim yapıldıkça olasılıklar burada görünecektir.</p>'; // Türkçe karakter düzeltildi
             closePredictionWarning.classList.add('hidden');

        });

        // Epoch slider'ı model Python'da eğitildiği için devre dışı bırakıldı
        epochSlider.addEventListener('input', (event) => {
            epochValueSpan.textContent = event.target.value; // Gerekirse yine de ekranı güncelle
        });

        // Başlangıçta canvas'ı siyaha temizle
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Sayfa yüklendiğinde WebSocket bağlantısını başlat
        // Model yükleme artık Python tarafında yapılıyor.
        // loadModel(); // Bu fonksiyon artık gerekli değil

    </script>
</body>
</html>
